**2.1-1 以图2-2为模型，说明INSERTION-SORT在数组A=<31,41,59,26,41,58>上的执行过程。**

简要说明如下：

31 41 59 26 41 58

26 31 41 59 41 58

26 31 41 41 59 58

26 31 41 41 58 59

**2.1-2 重写过程INSERTION-SORT，使之按非升序（而不是非降序）排序。**

将第五行中的A[i]>key改为A[i]<key。

**2.1-3 考虑以下查找问题：**

**输入：n个数的一个序列A=<$a_1,a_2, ……,a_n$>和一个值v。**

**输出：下标i使得v=A[i]或者当v不在A中出现时，v为特殊值NIL。**

**写出线性查找的伪代码，它扫描整个序列来查找v。使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要的性质。**

```pseudocode
LINEAR-SEARCH(A, v)
    for i = 1 to A.length
        if A[i] == v 
            return i
    return "NIL"
```

循环不变式：A[1……i-1]。

1.初始化：在循环开始前，因为未经过比较，可以确保循环不变式中没有等于v的元素；

2.保持：当下标为i的元素和v相等时，算法结束，否则继续判断下一个元素，直到序列中没有元素为止。因此循环不变式中没有与v相等的元素。

3.终止：由上述两点可以推出算法是正确的。

**2.1-4 考虑把两个n位二进制整数加起来的问题，这两个整数分别存储在两个n元数组A和B中。这两个整数的和应按二进制形式存储在一个（n+1）元数组C中。请给出该数组的形式化描述，并写出伪代码。**

形式化描述：

输入：两个n元数组A=<$a_1, a_2, ..., a_n$>和B=<$b_1, b_2, ..., b_n$>，其中$a_i$和$b_i$表示二进制数的第i位。

输出：一个（n+1）元数组C=<$c_1, c_2, ..., c_{n+1}$>，其中$c_i$表示二进制和的第i位。

```pseudocode
BINARY-ADDITION(A, B)
    n = A.length
    carry = 0
    C = new array of size (n + 1)
    
    for i = n downto 1 
        sum = A[i] + B[i] + carry
        C[i+1] = sum % 2
        
        if sum >= 2
            carry = 1
        else:
            carry = 0
    
    C[1] = carry  
    
    return C

```

